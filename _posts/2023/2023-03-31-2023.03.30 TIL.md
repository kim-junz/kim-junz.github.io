---
title: "2023.03.30 TIL" #제목 영역
date: 2023-03-31 #업데이트 날짜/시간
categories: [TIL] #카테고리를 나눠줄 수 있음?! TIL, WIL, Project
tags: [TIL] #태그예시: TIL, WIL, Project
---

`회고`
아 프록시.....  
저번에 배울때는 간단하게 진짜대신 가짜다! 정도까지만 이해했는데,  
이번에 좀 더 제대로 배웠다...  
아니 사실 프록시는 더 알려주셨었을수도... 내가 이해못한것일수도.....ㅠㅠ  
그래도 이번에는 이해를 했다 어떤 용도인지....

<h5><strong>프록시 이제 그만 놓아줄게</strong></h5>
프록시는.... 내가 getName을 요청했을때 프록시에서 이 명령(?)을 저장하고 있다가 실제로 print등으로 출력할때 DB에서 값을 가져오는거라고 이해하면 된다   
어휴 간단하네 너무 간단해서 어떡하지    
지금은 이렇게 간단히 쓰는데 강의들으면서는 이해가 되지 않아서 진짜 한참을 되감기해서 봤었다   
결국 이해는 했는데 좀 더 정확하게 프록시가 동작하는 원리를 알고싶어서 스승님한테 물어봤다

✅프록시의 동작 원리 단계

1. 프록시 객체 생성
   - 요청받은 엔티티 대신 프록시 객체를 생성
   - 프록시 객체는 실제 엔티티와 동일한 인터페이스를 가지며, 실제 엔티티를 대신해서 기능을 수행할 수 있음
2. 프록시 객체 반환
   - 프록시 객체를 반환
   - 이때, 실제 엔티티가 필요한 시점까지 데이터베이스 조회를 지연시킴
3. 프록시 객체 사용
   - 프록시 객체를 사용하여 엔티티의 속성 값을 가져오거나 메서드를 호출함
   - 이때, 프록시 객체가 실제 엔티티를 대신해서 기능을 수행함
4. 실제 엔티티 조회
   - 프록시 객체가 실제 엔티티가 필요한 시점에 데이터베이스 조회를 수행
   - 이때, 프록시 객체가 실제 엔티티를 가져오기 위해 영속성 컨텍스트를 통해 데이터베이스 조회를 수행함
5. 실제 엔티티 반환
   - 실제 엔티티를 반환
   - 이후부터는 실제 엔티티가 사용되어 기능을 수행하며, 프록시 객체는 더 이상 사용되지 않음

✅ 즉, 프록시는 실제 엔티티의 대리인 역할을 수행하며, 실제 엔티티가 필요한 시점에 데이터베이스 조회를 수행  
→ 이를 통해 불필요한 데이터베이스 조회를 줄여서 성능을 향상 시킴

처음에는 아니 1차캐시랑 다른게 뭐야..? 했는데  
1차캐시는 영속성컨텍스트에 캐시로 DB를 저장했다가 요청이 오면 꺼내서 주는 역할이고  
프록시는 그냥 실제로 요청이 있을때 값을 꺼내러 가는 게으른친구다.......  
이렇게 말하니 또 이해가 안되네 그러니까 1차 캐시는 저장소, 프록시는 실제로 그 데이터값을 필요로할때까지 요청을 지연시키는것  
만약 1차캐시에 이 값이 있다면 프록시가 아닌 바로 엔티티로 값이 반환된다  
저 둘은 완전 다른거였던거지...

기본 값이 프록시 타입인경우도 있지만, 아닌 경우도 있다.  
연관관계에서 `FetchType.LAZY` → Lazy로 할 경우 프록시 타입으로 값을 가져오게되고  
아닌데 나는 프록시 필요없는데 하면 Lazy가 아닌 `EAGER`로 설정해주면 된다.

그런데 가급적이면 `LAZY`를 사용하는게 좋다 `EAGER`로 설정할 경우 실무에서 예상치 못한 문제들이 많이 발생하고, 또 성능상으로도 썩 좋지는 않다  
절대사용하지마~~~

<h5><strong>산넘어 산으로 영속성 전이(CASCADE)</strong></h5>
영속성 전이는 특정 엔티티를 영속 상태로 만들 때 연관된 다른 엔티티도 함께 영속 상태로 만들고싶은 경우 사용한다   
연관관계에서 CASCADE를 지정하면 지정 속성값에 따라 연관된 엔티티를 함께 영속 상태로 만든다

참고로 영속성전이는 연관관계를 매핑하는것과는 아무런 관련이 없고,  
그냥 편의성을 위해서 만들어진거다

예를들면 parent 엔티티와 child 엔티티가 연관관계가 있다고 할때,  
parent도 생성하고 child도 한 5개쯤 생성한다음에 각각 persist 하기에는 너무 코드 반복이 심한것  
때문에 아래와 같이 cascade를 설정해 줄 경우(물론 부모 엔티티에서도 설정가능함)

```java
@OneToMany(mappedBy="parent", cascade=CascadeType.PERSIST)
```

부모와 함께 생명주기를 한다는 뜻이 된다  
위에 괄호안에 썼지만 부모, 자식 둘중 하나에 선언해도 양쪽 모두에게 적용된다고 스승님이 말해주었다... 아놔이거헷갈렸었네 ㅎ

`부모 엔티티에서 설정하기`

```java
@Entity
public class ParentEntity {
    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
    private List<ChildEntity> children;
    // other fields and methods
}

@Entity
public class ChildEntity {
    @ManyToOne
    private ParentEntity parent;
    // other fields and methods
}
```

`자식 엔티티에서 설정하기`

```java
Entity
public class ParentEntity {
    @OneToMany(mappedBy = "parent")
    private List<ChildEntity> children;
    // other fields and methods
}

@Entity
public class ChildEntity {
    @ManyToOne(cascade = CascadeType.PERSIST)
    private ParentEntity parent;
    // other fields and methods
}
```

속성으로는 아래와 같이 여러종류가 있으나 보통 all,persist 외에는 잘 사용하지 않는다고 한다

- ALL : 모두 적용 → 저장, 삭제 모든 라이프사이클을 동일하게 함께 적용
- PERSIST : 영속 → 저장만 하고 이후에는 parent가 삭제되도 삭제되지 않음
- REMOVE : 삭제 → 삭제될때만 함께 삭제됨
- MERGE: 병합
- REFRESH: REFRESH
- DETACH: DETACH

주의할점으로는 하나의 부모가 여러 자식들을 관리할때, 그리고 부모-자식 외에는 다른 연관관계가 없을때만 사용해야한다  
자식이 친구와 연결되어있는데 부모가 없어졌따고 자식도 함께 없어지면 연결되어있는 친구는 어떡해 ㅠㅠ  
어쨌든 단일 엔티티에 완 전 히 종속적일때만 사용해야한다

<h5><strong>고아객체</strong></h5>
처음 고아객체라는 단어를 봤을때 저게 무슨말이냐 싶었는데 ㅋㅋㅋㅋ   
고아객체는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 얘기한다..ㅠㅠㅠ   
진짜 고아객체가 뭐지했을때 상상도 못한 결과...ㅋㅋㅋ 영한님이 좀 슬픈얘기일수도 있다고 했다 ㅋㅋ...   
슬프긴하네요 ㅠㅠㅠ 왜 이름을 이렇게지었어 ㅠㅠ

자식 엔티티가 고아가 되어버리면 객체를 제거하도록 설정하는것이 있다  
`orphanRemoval = true` 영속성전이(CASCADE)와 함께 선언해주면 된다  
그러면 객체가 부모의 컬렉션에서 빠졌거나 하는 경우 바로 삭제된다ㅠㅠ 안돼 ㅠㅠ

`마무리`
배우면 배울수록 어려워지는데 이걸 어쩌면 좋냐...  
내가 진짜로 이걸 프로젝트에 녹여낼수 있을까 고민이 많다

영한님께서 어떤 기능을 사용할때는 그 기능이 어떤건지 알고 써야한다고 하셨다  
와, 나 이생각하면서 학원 하차한건데 여기 강의에서 들을줄은 몰랐다  
이렇게 왜이렇게 왜! 이렇게!! 깊게(^^)....알려주시나 하였는데학습에 있어서 나와 같은 마인드셨기 때문이었다

이렇게 자세히 알려주시는것도 사실 쉽지 않다  
내가 어디에 언제 써먹어야할지 모르는것은 아직 실전을 겪어보지 않아서다  
알고 있는것과 모르는것은 큰 차이지....  
어렵긴 해도 내가 어느정도 이해를 다 할 수 있다는건 얼마나 상세하게 설명해주셨다는 얘기야....  
이제 끝이 보여가니까 조금 힘이 나는것 같다 아니야 사실 안나 ㅠㅠ

다음 섹션도 좀 길다.. 아니 좀 많이 길다......  
열심히 들어봐야겠다
