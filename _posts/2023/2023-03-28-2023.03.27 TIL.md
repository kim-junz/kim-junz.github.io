---
title: "2023.03.27 TIL" #제목 영역
date: 2023-03-28 #업데이트 날짜/시간
categories: [TIL] #카테고리를 나눠줄 수 있음?! TIL, WIL, Project
tags: [TIL] #태그예시: TIL, WIL, Project
---

`회고`
오늘은 어제 예고했던대로 차량 검사소를 다녀왔는데,  
소통에 오류가 있어서 횡성까지 다녀왔다ㅋㅋㅋㅋ  
진짜 큰맘먹고 간건데 나는 저번에 그럼 차 검사를 큰맘먹고 다녀오는것처럼 썼는데 진짜 허무하네  
결론적으로 횡성에 헛걸음했고, 집으로 돌아오는길에 본가에 들려서 그곳에서 5분만에 검사를 마치고  
부모님과 함께 외식하고 바로 돌아왔다 ㅋㅋㅋ

아까운 시간만날렸네 코에 바람이나 들어가고 ㅋㅋ

오늘은 섹션5의 연관관계 매핑 기초를 들었는데 아직 다 듣지는 못했다.  
분명 단방향 연관관계까지는 괜찮았다  
그런데 양방향에서부터 약간 머리에 지진이 오기시작하더니 약간 어려워졌다...

<h5><strong>적당히해 H2....</strong></h5>
중간중간 삽질을 조금 하느라 시간을 많이 뺏기기도 했다   
이전에 새로운 데이터베이스를 생성해서 예제를 진행하고 난 뒤, 다시 test 데이터베이스에 연결하려고 했는데 오류가 났다

`오류내용` General error: "The write format 1 is smaller than the supported format 2 [2.0.204/5]" [50000-204] HY000/50000 (도움말)

위와 같은 오류였는데, ChatGPT한테 물어보니 버전이 안맞아서 그렇다는 얘기를 했다  
TEST DB랑 버전을 맞춰주라는데 뭔소린지 ㅠㅠㅠ  
그래서 오류로 검색을 해보니, 이전에 `생성`해두었던 TEST라는 이름을 가진 DB랑 버전이 다르다는것으로,  
해당 TEST DB와 버전을 맞춰주거나, TEST DB를 삭제 후 다시 만들면 되는거였음...

새로운 DB를 만들때, JPA에서 생성하는 법을 찾다가 H2를 지웠다가 다시 깔은일이 있는데,  
원래 새로운 DB를 만들기 이전에는 TEST라는 DB를 사용했었으니, 내가 생성하진 않았지만 있던거였다

어쨌든 나는 TEST를 삭제해도 상관없으므로 굳이 버전정보를 찾아서 맞는 버전을 다시 설치해줄 일은 없었고,  
그냥 삭제후 다시 생성하였다

{user}/test.mv.db  
{user}/test.trace.db

위 경로에 있는 test 관련 파일을 싹 지워주고 새로 생성하면 된다

<h5><strong>그만괴롭혀 H2.....</strong></h5>
그리고 이건 위 문제를 만나기 전.... 혼자 했던 삽질2 아니 엄연히 따지자면 삽질0인데,   
데이터베이스에서 실수로 연결 데이터 리스트를 지웠을때....   
그러니까 H2콘솔에 들어가서 아래 이미지에 있는 `삭제`버튼을 눌렀을때   
<img src="https://raw.githubusercontent.com/kim-junz/kim-junz.github.io/3531ae2cd6d6cbce80ac68aef91368afb894a91e/_posts/2023/post_img/23-03-27/01.png">   
그때 그러면 `저장한 설정`들이 하나씩 사라지게된다..^^   
사라질때 뭐 경고메세지도 없음.. 그냥 바로 삭제되는데 내가 저렇게해서 h2 데이터베이스를 지웠다는게 문제였다.....   
이거는 삭제 후 다시 설치해도 안되는거고 해당 설정파일을 지웠다가 다시설치한다면 모를까...   
제어판에서 삭제할때 설정파일들이나 DB까지 한번에 지워주는건 아닌것같았다...   
그러니 위에처럼 기존에 생성해둔 DB가 삭제안되서 고생하고, 지금처럼 설정파일이 초기화되지 않아서 고생했겠지..

어쨌든 결론을 얘기하자면 아래 경로에 있는 파일로 들어가서 설정만 다시 초기화해주면 된다  
`경로` {user}/.h2.server.properties

`.h2.server.properties`파일로 들어가보면 저장된 설정들 리스트가 보이는데, 내가 삭제했다면 이미 몇개가 비었을것이다  
삭제한 부분들을 추가해주면 되는데, 원래 설정은 아래와 같으므로 그냥 복붙해주면된다

✅ 코드 아니지만 코드로 올려둠...

```java
#H2 Server Properties
#Tue Mar 28 10:46:35 KST 2023
webSSL=false
webAllowOthers=false
webPort=8082
10=Generic DB2|com.ibm.db2.jcc.DB2Driver|jdbc\:db2\://localhost/test|
11=Generic Oracle|oracle.jdbc.driver.OracleDriver|jdbc\:oracle\:thin\:@localhost\:1521\:XE|sa
12=Generic MS SQL Server |||
13=Generic MS SQL Server 2005|com.microsoft.sqlserver.jdbc.SQLServerDriver|jdbc\:sqlserver\://localhost;DatabaseName\=test|sa
14=Generic PostgreSQL|org.postgresql.Driver|jdbc\:postgresql\:test|
15=Generic MySQL|com.mysql.jdbc.Driver|jdbc\:mysql\://localhost\:3306/test|
16=Generic HSQLDB|org.hsqldb.jdbcDriver|jdbc\:hsqldb\:test;hsqldb.default_table_type\=cached|sa
17=Generic Derby (Server)|org.apache.derby.jdbc.ClientDriver|jdbc\:derby\://localhost\:1527/test;create\=true|sa
18=Generic Derby (Embedded)|org.apache.derby.jdbc.EmbeddedDriver|jdbc\:derby\:test;create\=true|sa
19=Generic H2 (Embedded)|org.h2.Driver|jdbc\:h2\:~/test|sa
0=Generic JNDI Data Source|javax.naming.InitialContext|java\:comp/env/jdbc/Test|sa
1=Generic Teradata|com.teradata.jdbc.TeraDriver|jdbc\:teradata\://whomooz/|
2=Generic Snowflake|com.snowflake.client.jdbc.SnowflakeDriver|jdbc\:snowflake\://accountName.snowflakecomputing.com|
3=Generic Redshift|com.amazon.redshift.jdbc42.Driver|jdbc\:redshift\://endpoint\:5439/database|
4=Generic Impala|org.cloudera.impala.jdbc41.Driver|jdbc\:impala\://clustername\:21050/default|
5=Generic Hive 2|org.apache.hive.jdbc.HiveDriver|jdbc\:hive2\://clustername\:10000/default|
6=Generic Hive|org.apache.hadoop.hive.jdbc.HiveDriver|jdbc\:hive\://clustername\:10000/default|
7=Generic Azure SQL|com.microsoft.sqlserver.jdbc.SQLServerDriver|jdbc\:sqlserver\://name.database.windows.net\:1433|
8=Generic Firebird Server|org.firebirdsql.jdbc.FBDriver|jdbc\:firebirdsql\:localhost\:c\:/temp/firebird/test|sysdba
9=Generic SQLite|org.sqlite.JDBC|jdbc\:sqlite\:test|sa
20=Generic H2 (Server)|org.h2.Driver|jdbc\:h2\:tcp\://localhost/~/test|sa
```

<h5><strong>단방향 연관관계</strong></h5>
위와 같은 험난한 일들을 마무리하고, 드디어 단방향 연관관계에 대해서 들었다

이전까지는 객체를 테이블설계에 맞춰서 설계하였기 때문에 객체지향적인 설계가 아니었다  
테이블은 FK로 서로 테이블관 연관관계를 만드는데, 객체로 이를 따라하면 분명 연결이 되어있는 값임에도 불구하고  
연관관계가 없어져버린다. 이건 직접 보고 이해해야지 내가 말로 설명한다고 설명이 될 수 있는 부분은 아닌듯 ㅠㅠ

먼저 데이터 테이블간의 관계를 살펴보았다  
멤버와 팀이라고 가정을 하면,  
팀은 여러명의 멤버를 가질 수 있고  
멤버는 한개의 팀만 가질 수 있다.

멤버의 입장에서 보았을때 팀ID가 팀 테이블과 연결해주는 FK인것

나도 예전에는 TEAM_ID 해서 설계했을테지만, 캬 진짜 3년만에 왜이렇게 많이바뀐거야...  
member Entity에서 team을 Team 타입으로 선언해주고 해당 데이터는 @ManyToOne의 관계인것을 어노테이션으로 달아주었다  
여기에서 member가 Many이다.  
ManyToOne, OneToMany 등 있지만 나는 해당 어노테이션을 선언하고 있는 엔티티의 기준이 제일 처음 온다고 생각하기로 하였다  
그러니까 member가 Many, team이 One인거지...  
그리고 Team 테이블에 있는 TEAM_ID와 @JoinColumn으로 join만 해주면 끝..! 많이 간단해졌다!

```java
   @ManyToOne
   @JoinColumn(name = "TEAM_ID")
   private Team team;
```

JPA를 접하면서 이 데이터부분이 너무 간단해진것같다 ㅠㅠ 앞으로 이직할 회사는 이 JPA를 썼으면 좋겠당...  
데이터를 다루기위해 쿼리 작성하는게 나한테는 너무 .....힘들것같은데 ㅠㅠ

어쨌든 저렇게 진행하면 단방향 연결 성공....  
놀랍게도 member는 team의 정보를 갖고있으니 팀의 ID뿐만 아니라 이름도 조회할 수 있다.

`마무리`  
양방향 연관관계는 아직 제대로 이해한게 아니므로 내일 작성하는것으로 패스한다...  
이런 생각지도 못한것들이 내 발목을 잡으니 강의가 진도가 안나가지...!  
그래도 좋은 경험이긴했다... 무조건 재설치 말고 다른 길을 찾아보도록하자....... 괜히 고생했네 ㅠㅠ  
양방향.. 하 진짜 머리에 지진오는데 영속성 컨텍스트랑 이 연관관계가 중요한거라고 하니까 잘 이해해보도록 하자
