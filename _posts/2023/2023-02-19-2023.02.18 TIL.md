---
title: "2023.02.18 TIL" #제목 영역
date: 2023-02-19 #업데이트 날짜/시간
categories: [TIL] #카테고리를 나눠줄 수 있음?! TIL, WIL, Project
tags: [TIL, 항해99] #태그예시: TIL, WIL, Project
---

`회고`
평일동안은 알고리즘 문제와 열심히 싸웠는데,  
이번 주말에는 개념정리, 용어정리를 하면서 보내고싶었으나....  
월요일에 있을 알고리즘 예상문제를 풀어봐야했다.

<h5><strong>몇시간 했더라?(중)</strong></h5>  
- 체크인, 체크아웃 시간을 기록하고 주간 몇시간 공부했는지 추출하는 알고리즘 작성  
- 체크인, 체크아웃은 정시에 한것으로 가정  
- 시간은 밤 12시를 24시간, 이후 1시로 넘어가면 25시, 26시로 계산됨  
- 새벽 5시를 넘어가면 체크아웃을 깜빡한것으로 간주하여 21시 체크아웃으로 처리됨

📌 입출력 예

| CheckIn         | CheckOut               | result |
| --------------- | ---------------------- | ------ |
| [9,9,8,8,7,8,9] | [25,30,29,22,23,30]    | 96     |
| [9,7,8,9,7,9,8] | [23,22,26,26,29,27,22] | 110    |
| [9,9,9,9,7,9,8] | [23,23,30,28,30,23,23] | 102    |

📌 문제풀이

```java
public class test {
    public static void main(String[] args) {
            int[] checkin = new int[] {9, 9, 8, 8, 7, 8, 9};
            int[] checkout = new int[] {21, 25, 30, 29, 22, 23, 30};
            int[] new_out = new int[checkout.length];
            //29이상일시 21로 초기화

            int res = 0;

            for(int i =0; i < checkout.length; i++){
                new_out[i] = checkout[i];
                if(checkout[i] >= 29){
                    new_out[i] = 21;
                }
            }
            for(int a = 0; a <checkin.length; a++){
               res += new_out[a] - checkin[a];
            }
            System.out.println(res);
    }
}
```

먼저, 새벽5시 이후일 경우(29 이상) 21로 바꿔주면서 배열을 checkout 배열을 복사하였다.  
그리고 for문으로 복사한 체크아웃 배열(new_out)에서 checkin을 빼준 후 res에 총 시간을 저장하도록 작성하였다.  
난이도 중 문제라고 하는데 금방 진행할 수 있을정도로 쉬웠다.

<h5><strong>소수의 개수와 덧셈 (상)</strong></h5>  
- 문자열 s에는 공백으로 구분된 숫자들이 저장되어있음  
- 숫자중에 소수의 최대값과 소수가 아닌 수의 최소값을 찾아 이를 "(최소값) (최대값)" 형태로 반환  
- 문자열에는 소수인 숫자, 소수가 아닌 수가 한개 이상 섞여있음  
- 음수는 없음

📌 입출력 예

| s                      | result  |
| ---------------------- | ------- |
| "2 3 4 5"              | "4 5"   |
| "15 3 10 9 7 8"        | "8 7"   |
| "97 75 88 99 95 92 73" | "75 97" |

📌 문제풀이

```java
import java.util.Arrays;

public class Test3 {
    public static void main(String[] args) {
        String s = "15 3 1 9 7 8";
        String answer = "";

        String[] str = s.split(" ");
        Arrays.sort(str);
        int[] arr = new int[str.length];

        for(int i=0; i < str.length; i++){
            arr[i] = Integer.parseInt(str[i]);
        }

        int min = arr[arr.length-1];
        int max = arr[0];

        for (int idx = 0; idx < arr.length; idx++){
            int cnt = 0;
            for(int j=2; j <= arr[idx]; j++) {
                if (arr[idx] % j == 0) {
                    cnt++;
                    if (cnt > 1 && min > arr[idx]) {
                        min = arr[idx];
                    }
                }
            }
                if(cnt == 1){
                    if(max < arr[idx]){
                        max = arr[idx];
                }
            }
        }
        answer = min + " " + max;
        System.out.println(answer);
    }//메인
}
```

와 이렇게 푸는건지는 잘 모르겠으나ㅠㅠ  
먼저 문자열 s를 split을 이용해 공백을 기준으로 잘라서 String 배열 str에 넣어줬다.  
그리고 이 str을 오름차순으로 sort해주었다 > 이 이유는 이후에 min에는 배열의 가장 큰숫자를 초기값으로 잡고, max에는 가장 작은숫자를 초기값으로 잡기위해서 하였다.

for문으로 이 str을 다시 int형 배열에 담아주었다.  
그리고 가장 소수인 가장 큰수와 소수가 아닌 수의 가장 작은수를 변수로 초기화해주고

2중for문으로 배열을 돌면서, 그 배열에 담긴 숫자의 소수 여부를 판단하고자 하였다.  
두번째 for문에서는 1부터 시작하지 않고 2부터 시작해서 1을 제외한 자기자신 외에 나눠지는 숫자가 있는지 여부를 판단하고자 하였다  
만약 배열의 숫자를 1부터 n까지 돌았을때 나눠서 0이 되는 숫자가 있으면 if문을 들어오고, 그 if에서 cnt값을 증가시켰다.  
그와 동시에 cnt가 1이상이고, min에 있는 숫자보다 작을경우에는 min에 들어가도록 처리하여 소수가 아닌수의 최소값을 찾아내었다.  
만약 cnt가 1인 상태에서 빠져나왔다면 자기 자신으로만 나눴던것이기 때문에 max와 비교해서 max보다 클 경우에는 해당 배열의 숫자를 담도록 하였다.  
그리고 다시 for문을 시작하면 cnt는 0으로 초기화된다.

상 문제인만큼 어려웠는데, 그래도 나에겐 제일 어려운 하 문제가 있었다...

<h5><strong>신대륙 발견</strong></h5>
- 임의의 month와 day값이 주어진다   
- 해당 주어진 월, 일을 1일로 99일째 되는 날이 몇월 몇일인지 계산해주는 알고리즘 구현

📌 제한 조건

- 1 ≤ month ≤ 12
- 1 ≤ day ≤ 31 (2월은 28일로 고정합니다, 즉 윤일은 고려하지 않습니다.)

📌 입출력 예

| month | day | result     |
| ----- | --- | ---------- |
| 11    | 27  | "3월 5일"  |
| 6     | 22  | "9월 28일" |
| 1     | 18  | "4월 26일" |

위 문제인데 ㅠㅠ 내가 너무 꼬아서 생각하나, 위 문제가 가장 어려웠다.  
입출력 예시 샘플 테스트로는 통과하였는데,  
임의의 월,일을 넣었더니 n월 0일이 나와서 깜짝놀랐다.......

이부분은 다시 풀어보아야겠다.  
오래걸리겠지만 해봐야겠지ㅠㅠ

알고리즘이 이렇게 나를 괴롭힐줄은 몰랐다. 꾸준한 공부가 필요한 부분인건 알고있지만...  
이렇게까지 많은 시간을 투자하면서 문제만 주구장창 풀기에는 내가 아직 개념이 많이 부족하다.  
일단 진도니까 따라가고는 있는데 개인적으로 부족한부분을 더 보충할 시간이 없는것이 많이 화가 난다.

문제를 푸느라 시간을 모두 써버리는 바람에 이렇게 되어버린거라 스스로에게 많이 짜증이나고 화가났다.  
잠을 줄일만큼 줄였고 밥도 책상앞에 앉아서 먹는 수준인데...  
답답하기만 하다
