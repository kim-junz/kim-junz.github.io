---
title: "2023.03.17 TIL" #제목 영역
date: 2023-03-18 #업데이트 날짜/시간
categories: [TIL] #카테고리를 나눠줄 수 있음?! TIL, WIL, Project
tags: [TIL] #태그예시: TIL, WIL, Project
---

`회고`     
토요일 작업실에 혼자 있게 되어 열공하였다.   
꽤 긴 섹션이었던 7섹션을 모두 다 듣고 8섹션까지 끝냈다   

이번 강의는 왜이렇게 길지, 길지 싶었는데   
이론이라서 정리할것도 많았고, 원래 강의 자체가 기네........   

실전파인 나한테는 너무나 고역이긴 했지만 정말 포기하지 않고 꾸역꾸역 들었다.   
이후 HTTP를 거쳐서 JPA를 들으면서 프로젝트를 구상하고 JPA 로드맵이 끝나면 프로젝트를 시작할것이지만   
프로젝트를 진행하는 중에도 스프링 로드맵은 계속 들어야겠다. 조금씩이라도   
 
매번 모르겠다 개발자로써 나를 증명해야하는데,   
내가 그걸 잘 해낼수 있을지 잘 모르겠다.   
항상 올려다보기만 해서 이 허들의 높이가 내가 어느정도의 힘으로 뛰어야 넘을수 있는것인지 잘 모르겠다   
지금도 잘 모르겠다   
내가 어느정도를 하고 있어야 회사에 가서도 온전히 한명의 몫을 해낼수 있는것인가   
이것에 대한 걱정과 고민이 너무 많다.   

학원도 아무것도 없는 제로중의 제로베이스인데 잘 해낼수 있을까 하는 고민이 여전히 나를 괴롭힌다   
그렇다고 다시 기획자로 돌아갈수도 없다   
저 허들이 높든 어쨌든간에 기어서라도 넘어가야한다 ㅠㅠ   

<h5><strong>의존관계 자동 주입</strong></h5>

7섹션의 내용은 의존관계 자동 주입하는 방법 4가지를 배웠다.   
이부분에 대해서는 원래 알고있는 내용이긴 했는데, 예제와 함께 더 자세히 학습하였다.   
짧게 정리를 해보자면,   

의존관계를 주입할 수 있는 방법으로 `생성자 주입`, `수정자(setter)주입`, `필드 주입`, `일반 메서드 주입`이 있다   
이전에는 메서드주입은 보지 못한 방법이어서 신기했는데 거의 setter주입과 비슷하기 때문에 잘 사용하지 않아서 다른 개념에서는 합쳐진게 아닐까 싶다   
갓영한님 강의에서도 `있다`정도까지만 알고 넘어갔다    

위에서 설명한대로 메서드주입은 setter주입과 비슷하기 때문에 제외되었고,   
필드주입은 코드가 간결하고 간편해서 개발자들을 유혹하기는 하지만(나도 혹하긴했다) 하지만 외부에서 변경이 불가능하여 테스트하기 힘들다는 단점이 있다.   
그리고 이제 스프링에서는 이렇게 필드주입을 권하지 않는다.   
필드주입을 진행할경우 `권하지 않음!`이라고 경고 밑줄도 그어준다   

그럼 주로 사용하는것은 생성자주입과 수정자(setter)주입인데, 둘중 뭘 선택해야할까?   
당연히 답은 `생성자 주입`이다   

이유는 꽤 많지만 주입은 보통 시작부터 종료까지 의존관계를 변경할일이 없음, 아니 변경하면 안됨   
생성자 주입은 객체를 생성할때 딱 한번만 호출되므로, 불변하게 설계가 가능하다   

수정자의 경우에는 setXx 메서드를 public 으로 열어두어야 하기 때문에 누군가 실수로 변경할수도 있고,   
변하면 안되는 값을 저렇게 열어두는것은 좋은 설계방법이 아니다 → 위험을 안고가니까 당연하겠지만   

그리고 생성자로 진행할경우에는 주입 데이터를 누락하였을때 컴파일 오류가 발생하고,   
누락하기 이전에 IDE에서 어떤 값을 필수로 주입해야하는지 알려주기 때문에 실수를 줄일 수 있다   

수정자의 경우에는 누락하였는지... 아닌지.... 모르다가 실행 후 오류로 나의 실수를 확인할 수 있다   

마지막으로 생성자 주입은 final키워드를 사용할 수 있고, 생성자에서 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에서 막아준다   
생성자 주입 외에 나머지 주입 방식은 생성자이후에 호출되므로 final 키워드를 쓸 수 없는것....   

정리하자면 항상 생성자 주입을 선택! 가끔 옵션이 필요하면 수정자 주입을 선택...   
그외에는 왠만해서는 쓰지말자   
필드주입은 가끔 테스트코드에서 쓸때도있다   

줄여보자면 이정도인것같다.   

<h5><strong>Lombok</strong></h5>
그런데 롬복이 나왔네   
처음에 이름이상해서 저게뭐여 싶었는데, 완전 편리한 친구였다...   

학원에서 학습할때 롬복이 뭔지 설명도 안해주고 그냥 가져다가 썼는데, 드디어 이친구가 뭔지 알게되었다   
롬복은 라이브러리 설치가 필요하다   

롬복을 사용하면, 클래스에 `@RequiredArgsConstructor`하나만 적용하면 @Autowired와 생성자를 따로 선언해주지 않아도   
알아서 생성자를 찾아서 주입해줌.... 코드가 안쓰여있을뿐이지 내부에서 모두 처리해줌...   
얼마나 편한가........   
`@RequiredArgsConstructor`가 클래스에 선언된 모든 final 필드를 인자로 받는 생성자를 생성해서 알아서 넣어주는것이었다   
갓영한님께서도 롬복없이는 개발못한다고(?)ㅋㅋㅋㅋㅋ   

@RequiredArgsConstructor로 생성자를 자동으로 생성하면,    
→ final 필드들이 초기화될 때 Null 값을 가지지 않으므로 NullPointerException이 발생할 확률을 줄일 수 있으며, 코드의 가독성도 향상 됨   
개발자들이 안쓸이유가 없지........   
아직 실전에 막 적용해보고 이런 상태는 아니기 때문에 아는 정도만 하고 지나갔다   
나중에 많이 써먹을것같다   

<h5><strong>빈 생명주기와 콜백</strong></h5>
그ꈰ고 섹션8에서는 빈의 생명주기에 대해서 배웠다   
빈은 시작할때 초기화 메서드, 소멸직전에 종료 메서드를 호출할 수 있는 기능이 있다.   
여러가지 기능이 있지만 초기화, 소멸 메서드는 @PostConstruct, @PreDestroy 방법을 기본적으로 사용하고,   
다만 외부 라이브러리에서 써야한다면 @Bean(initMethod = "init", destroyMethod = "close")를 쓰면 될것같다.   

언제쓰는지는 아직 실전 적용을 안해봐서 모르겠다.   
이번 강의들은 모두 `스프링에는 이런 기능들이 있다!`정도여서    
처음에는 뭔데... 뭔데..! 어떻게 이해해야하는데!!! 하고 혼란스러웠지만   
지금은 `응 있구나^_^...`까지만 하고 지나가고있다.   

`마무리`   
위에서 얘기한 빈은 스프링 컨테이너가 시작될때부터 끝날때 소멸되는 싱글톤 빈이고,   
보통은 이 싱글톤 빈이 기본적인 빈 형태이지만,   
스프링은 싱글톤 빈 외에 여러 빈을 제공하고있다   
그중 프로토타입빈과 웹 스코프 빈에 대해서 학습하고있는데, 프로토타입 빈은 잘 사용하지 않는다고 했다   
이제 웹 관련해서 학습중인데 이부분만 끝나면 이론은 끝난다.   
얼른 실기하고싶어서 정말 근질거린다 ㅠㅠ   
직접 해봐야 기억에도 오래남지.....   

벌써 3월 말이 다가오고 있다. 잘 해낼수 있을까 고민도 고민이지만 일단 부딪쳐봐야지..   
생각보다 늘어지고있는 일정때문에 초조해서 그런것같은데,   
계속 마음을 가다듬도록 노력해야겠다.   
